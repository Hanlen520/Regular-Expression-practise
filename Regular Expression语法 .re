Regular Expression语法
1.纯文本匹配
word

2. .表示匹配任意一个单个字符，包括字母、数字或者点“.”本身(除换行符以外的任意单个字符)
apple.

3.一个正则表达式里面允许有多个.
appl..
.ppl.

4.如果真的需要.这个字符，那就需要在前面加上斜杠表示转义字符
apple\.
如果需要斜杠，就变成了\\：
apple\\

正则表达式经常被简称为模式
普通字符：纯文本
元字符：在正则表达式里有特殊含义的特殊字符

5.使用[]匹配多个字符中的某一个
[abcd]pple
结果中只会搜索pple前面是a或者b或者c或者d的字符串
[Rr]egular
[Aa]pple
一般用于在某个特定成分不需要区分大小写的字符串

6.使用-匹配一个字符区间
[a-z]pple
[0-9]pple
[A-D]pple
表示在区间内ASCII码顺序的所有
连字符-的这个作用只在[]内有用，在[]外表示的就是连字符-本身，不是别的特殊含义
千万不要写[3-1]这样第一个比第二个大的情况，因为这个区间是没有意义的，往往会让整个模式失效

7.取非匹配^
^用于排除那些不需要得到的字符，比如不希望在a.c中间出现的是数字：
a[^0-9]c

8.对元字符来说，要匹配元字符本身，就需要用\来转义
\[
\]
\.
\\
如果不这样的话，正则表达式分析器很可能会抛出一个错误
外加还有：
\+
\*
\?

9.匹配空白字符
[\b] 回退（并删除）一个字符(Backspace键)
\f 换页符
\n 换行符
\r 回车符
\t 制表符（Tab键）
\v 垂直制表符

所以搜索两条记录中的空白行：
Windows系统：\r\n\r\n
Unix、Linux系统：\n\n

10.匹配数字（或者非数字）
\d 表示任何一个数字字符，等价于[0-9]
\D 表示任何一个非数字字符，等价于[^0-9]
(所以说可以得知：正则表达式的语法是区分大小写的)

11.匹配字母数字和下划线（或者非字母数字下划线）
\w 表示一个字母数字或者下划线字符，等价于[a-zA-Z0-9_]
\W 表示一个非字母数字或下划线字符，等价于[^a-zA-Z0-9_]

12.匹配空白字符（与非空白字符）
\s 表示一个空白字符，等价于[\f\n\r\t\v]
\S 表示一个非空白字符，等价于[^\f\n\r\t\v]
注意：\b不在\s的覆盖范围之内（所以在\S的覆盖范围之内）

13.通过给出某个特定字符的八进制或者十六进制来匹配它本身
八进制：
在前面加\0：如\011表示ASCII字符9，也就是制表符\t
十六进制：
在前面加\x

14.使用\c匹配控制字符（较少见）
\cZ将匹配Ctrl-Z

15.使用POSIX字符类（许多正则表达式都支持，不过Javascript不支持）
[:alnum:] == [a-zA-Z0-9]
[:alpha:] == [a-zA-Z]
[:blank:] 空格或者制表符 等价于 [\t] (注意最后有个空格哦~)
[:cntrl:] ASCII控制字符(也就是ASCII 0-31，再加上ASCII 127)
[:digit:] == [0-9]
[:graph:] 和[:print:]一样，但不包括空格
[:lower:] 任何一个小写字母，等价于[a-z]
[:print:] 任何一个可打印的字符
[:punct:] 既不属于[:alnum:]也不属于[:cntrl:]的任何一个字符
[:space:] 任何一个空白字符，包括空格，等价于[^\f\n\r\t\v] (注意最后面有个空格哦~~~~)
[:upper:] 任何一个大写字母，等价于[A-Z]
[:xdigit:] 任何一个十六进制数字，等价于[a-fA-F0-9]

比如说检验一个RGB值：
#[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]]

16.匹配一个或者多个字符，使用+
\w+@\w+\.\w+可以用来匹配一个电子邮箱地址
+匹配一个或者多个字符，至少一个

但是上面的例子不能匹配liu.chuo@qq.com这种前面名字就出现了.字符的字符串，所以可以改成：
[\w.]+@[\w.]+\.\w+

在字符集合里面使用的时候，.或者+这些可以不用转义，但是转义了也没有坏处：
[\w.] == [\w\.]

17.匹配0个或者多个字符，使用*
为了避免电子邮箱地址里面第一个字符是.的不合法情况，可以采取下面的方法：
\w+[\w.]*@[\w.]+\.\w+

18.匹配0个或1个字符，使用?
比如可以接受http:和https:两种，s可以出现0次或者1次
https?:

关于windows里面是\r\n\r\n，而Unix里面是\n\n的情况，可以这样处理：
[\r]?\n[\r]?\n

19.设置匹配的重复次数，使用{}
所以上面那个RGB的颜色检验的语句：
#[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]]
可以写成：
#[[:xdigit:]]{6}

20.为重复匹配次数设定区间，如{1,5}
a{2,4}
最少重复2次，最多重复4次

重复次数也可以是0，比如{0,5}

21.至少重复次数匹配：最少重复3次 {3,}
$\d{3,}
就能把$100之上的所有价格都选出来

22.* + {n,}都是多多益善的，会匹配到能够满足的最长的情况，如果我们需要的是最短的情况，可以在符号后面加上?
比如：
<[Bb]>.*?<[Bb]>
给它们加上?后，它们就变成了懒惰型字符


23.使用\b限定边界
\bcat\b  可以防止检测出含有cat的长单词，因为左右需要有边界才能被检验出来（b => boundary）
\bcat  以cat为后缀
cat\b  以cat为前缀

24.反之，\B表示不是单词边界
\B-\B  检验前后都不是单词边界的连字符

25.字符串边界：
定义字符串开头的^，和定义字符串结尾的$
（^只有放在[]里面且左边紧跟[的时候才会表示求非的意思，其他时候是字符串开头的边界符）

^\s*<\?xml.*\?>
</[Hh][Tt][Mm][Ll]>\s*$

26.分行匹配模式
在前面加(?m)能够让正则表达式引擎把行分隔符当做一个字符串分隔符来对待
(?m)^\s*//.*$

27.子表达式
补充：&nbsp;表示非换行型空格 "non-breaking space"
比如想检验超过两次出现非换行型空格的地方的时候，使用：
&nbsp;{2,}
是错误的，因为只会检验;出现2次以上的

所以用：
(&nbsp;){2,}

此时(&nbsp;)是一个子表达式，被看作一个独立元素

所以检验ip地址可以写成：
\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}
也可以写成：
(\d{1,3}.){3}\d{1,3}

28. |操作符
检验出生年份是否合法，限定只能19或者20开头：
(19|20)\d{2}
因为|操作符（叫或操作符）是把后面当做一个整体来看待的，所以必须要在19|20两边加上括号，这样才能保证后面的\d{2}不被或操作符包括在内

或操作符也可以写多个：
(19|20|21)\d{2}


29.子表达式可以嵌套

30.回溯引用：允许正则表达式模式引用前面的匹配结果
匹配重复出现了两次的单词：
[ ]+(\w+)[ ]+\1
(\w+)两边的小括号的作用是用来表示这里面是一个子表达式，\1代表模式里面的第1个子表达式，\2代表模式里面第2个子表达式……以此类推
所以说，子表达式是通过它们的相对位置来引用的

所以匹配一个HTML标题标签（h1~h6都行，但是前后两个标签的数字必须一致）：
<[Hh]([1-6])>.*?</[Hh]\1>

回溯引用只能用来引用模式里面的子表达式（就是用小括号括起来的正则表达式片段）
\0可以用来表示整个正则表达式


31.使用$1这样的形式使用替换功能
把文中所有电子邮箱地址替换成可点击的：
查找电子邮箱地址的代码：(\w+[\w\.]*@[\w\.]+\.\w+)
替换操作的代码：<A HERF = "mailto:$1">$1</A>

$1表示第一个子表达式，$2表示第二个子表达式……以此类推

32.用来进行大小写转换：
\E  结束\L或者\U转换
\l  把下一个字符转换为小写
\L  把\L到\E之间的字符全都转换为小写
\u  把下一个字符转换为大写
\U  把\U到\E之间的字符全部转换成大写

正则表达式：(<[Hh]1>)(.*?)(</[Hh]1>)
替换：$1\U$2\E$3


33.前后查找：包含的匹配本身并不返回，而是用于确定正确的匹配位置，它并不是匹配结果的一部分

34.向前查找：指定了一个必须匹配但不在结果中返回的模式 使用 ?=
.+(?=:) 表示只要找到:就行了，不要把它包括在最终的匹配结果里

35.向后查找：查找出现在被匹配文本之前的字符  使用  ?<=
(?<=\$)[0-9.]+

向前查找模式的长度是可变的，它们可以包含. + 之类的元字符，所以它们非常灵活，而向后查找模式只能是固定长度

36.向前查找和向后查找的结合：
比如想查找一个title标签内的内容，但是不想包含title标签
(?<=<[Tt][Ii][Tt][Ll][Ee]>).*(?=</[Tt][Ii][Tt][Ll][Ee]>)

37.对前后查找取非：负向前查找和负向后查找（不常用）
(?!)  负向前查找：向前查找不与给定模式相匹配的模本
(?<!) 负向后查找：向后查找不与给定模式相匹配的文本

38.正则表达式里面的条件： 使用?
(<h1>)(?(1)</h1>)
如果第一个回溯引用存在，那么就检验后面的内容。

39.前后查找条件
只在一个向前或者向后查找操作中取得成功的情况下采允许一个表达式被使用
查找是否满足5个数字或者5个数字外加连字符和4个数字的情况
\d{5}(?(?=-)-\d{4})
?=-用来匹配一个连字符（但不消费），如果条件得到满足（那个连字符存在），-\d{4}将匹配那个连字符和随后的4个数字。









